<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ê¢ÖËä±Êô∫ËÉΩÊä†Âõæ</title>
    <style>
        /* Base styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f8f5f2;
            color: #333333;
        }
        
        /* Utility classes */
        .h-screen { height: 100vh; }
        .h-[70px] { height: 70px; }
        .h-[60px] { height: 60px; }
        .h-6 { height: 24px; }
        .h-8 { height: 32px; }
        .h-[30px] { height: 30px; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .flex-row { flex-direction: row; }
        .flex-1 { flex: 1; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .space-x-1\\.5 > * + * { margin-left: 6px; }
        .gap-5 { gap: 20px; }
        .gap-[10px] { gap: 10px; }
        .gap-[15px] { gap: 15px; }
        .p-5 { padding: 20px; }
        .p-[15px] { padding: 15px; }
        .px-5 { padding-left: 20px; padding-right: 20px; }
        .px-[15px] { padding-left: 15px; padding-right: 15px; }
        .py-1 { padding-top: 4px; padding-bottom: 4px; }
        .mr-2 { margin-right: 8px; }
        .mr-4 { margin-right: 16px; }
        .mr-5 { margin-right: 20px; }
        .mr-[10px] { margin-right: 10px; }
        .mt-0\\.5 { margin-top: 2px; }
        .mt-2 { margin-top: 8px; }
        .mb-[15px] { margin-bottom: 15px; }
        .ml-[10px] { margin-left: 10px; }
        .m-0\\.5 { margin: 2px; }
        
        /* Width/Height utilities */
        .w-10 { width: 40px; }
        .w-20 { width: 80px; }
        .w-2 { width: 8px; }
        .w-[60px] { width: 60px; }
        .w-[120px] { width: 120px; }
        .w-full { width: 100%; }
        .max-w-full { max-width: 100%; }
        .max-h-full { max-height: 100%; }
        .min-w-0 { min-width: 0; }
        .min-h-0 { min-height: 0; }
        
        /* Border radius */
        .rounded-lg { border-radius: 8px; }
        .rounded-md { border-radius: 6px; }
        .rounded-full { border-radius: 9999px; }
        .rounded-[12px] { border-radius: 12px; }
        .rounded-[2px] { border-radius: 2px; }
        .rounded-[30px] { border-radius: 30px; }
        
        /* Font sizes */
        .text-[10px] { font-size: 10px; }
        .text-[13px] { font-size: 13px; }
        .text-[14px] { font-size: 14px; }
        .text-[18px] { font-size: 18px; }
        .text-[20px] { font-size: 20px; }
        .text-xs { font-size: 12px; }
        .text-2xl { font-size: 24px; }
        
        /* Font weights */
        .font-bold { font-weight: 700; }
        .font-medium { font-weight: 500; }
        .font-sans { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif; }
        
        /* Colors */
        .bg-white { background-color: white; }
        .bg-cBg { background-color: #f8f5f2; }
        .bg-cAccent { background-color: #e8a798; }
        .bg-cAccentHover { background-color: #d89788; }
        .bg-[#f9fafb] { background-color: #f9fafb; }
        .bg-cLight { background-color: #e0e0e0; }
        .bg-[#4ade80] { background-color: #4ade80; }
        .bg-red-500 { background-color: #ef4444; }
        .bg-[#fbbf24] { background-color: #fbbf24; }
        .bg-gray-50 { background-color: #f9fafb; }
        
        .text-cPrimary { color: #333333; }
        .text-cSecondary { color: #666666; }
        .text-cAccent { color: #e8a798; }
        .text-white { color: white; }
        .text-[#ccc] { color: #cccccc; }
        
        /* Borders */
        .border { border: 1px solid #e5e7eb; }
        .border-cLight { border: 1px solid #e0e0e0; }
        
        /* Display */
        .hidden { display: none; }
        .block { display: block; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        
        /* Position */
        .shrink-0 { flex-shrink: 0; }
        .z-10 { z-index: 10; }
        .z-20 { z-index: 20; }
        
        /* Object fit */
        .object-contain { object-fit: contain; }
        
        /* Overflow */
        .overflow-hidden { overflow: hidden; }
        
        /* Transitions */
        .transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; }
        .transition-opacity { transition-property: opacity; }
        
        /* States */
        .hover\\:opacity-70:hover { opacity: 0.7; }
        .hover\\:opacity-80:hover { opacity: 0.8; }
        .hover\\:bg-cAccentHover:hover { background-color: #d89788; }
        .hover\\:bg-gray-50:hover { background-color: #f9fafb; }
        
        .disabled\\:opacity-50:disabled { opacity: 0.5; }
        .disabled\\:cursor-not-allowed:disabled { cursor: not-allowed; }
        
        /* Text alignment */
        .leading-tight { line-height: 1.25; }
        .uppercase { text-transform: uppercase; }
        .tracking-[1px] { letter-spacing: 0.025em; }
        
        /* Custom cursor */
        .cursor-pointer { cursor: pointer; }
        .cursor-not-allowed { cursor: not-allowed; }
        
        /* Checkerboard pattern */
        .checkerboard {
            background-color: #f8f5f2;
            background-image:
              linear-gradient(45deg, #e0e0e0 25%, transparent 25%),
              linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),
              linear-gradient(45deg, transparent 75%, #e0e0e0 75%),
              linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        
        /* Animation */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }

        /* Selection box styles */
        .selection-container {
            position: relative;
            width: 100%;
            height: 100%;
            justify-content: center;
            align-items: center;
            cursor: crosshair;
            z-index: 10;
        }

        #source-img {
            display: block;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            pointer-events: none;
        }

        .selection-box {
            position: absolute;
            border: 2px solid #e8a798;
            background: transparent;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }

        .selection-corner {
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid #e8a798;
            border-radius: 50%;
        }

        .corner-tl { top: -6px; left: -6px; }
        .corner-tr { top: -6px; right: -6px; }
        .corner-bl { bottom: -6px; left: -6px; }
        .corner-br { bottom: -6px; right: -6px; }

        .selection-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }

        /* Polygon Styles */
        .polygon-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }
        
        .polygon-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid #e8a798;
            border-radius: 50%;
            cursor: move;
            transform: translate(-50%, -50%);
            z-index: 30;
            pointer-events: auto;
        }
        
        .polygon-point:hover {
            background: #e8a798;
        }

        .selection-tooltip {
            position: absolute;
            inset: 0;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .selection-container:hover .selection-tooltip {
            opacity: 1;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin-left: 10px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #e8a798;
        }
        
        input:checked + .slider:before {
            transform: translateX(20px);
        }
    /* Loading overlay styles */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(248, 245, 242, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        transition: opacity 0.3s ease-out;
    }

    .loading-content {
        text-align: center;
        max-width: 80%;
    }

    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(232, 167, 152, 0.3);
        border-top: 5px solid #e8a798;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
    }

    .loading-text {
        color: #333333;
        font-size: 16px;
        margin-bottom: 10px;
    }

    .loading-progress-bar {
        width: 80%;
        height: 6px;
        background-color: #e0e0e0;
        border-radius: 3px;
        overflow: hidden;
        margin-top: 15px;
    }

    .loading-progress {
        height: 100%;
        width: 0%;
        background-color: #e8a798;
        transition: width 0.3s ease;
    }

    .loading-hidden {
        display: none;
    }
    </style>
</head>
<body class="bg-cBg h-screen flex flex-col font-sans text-cPrimary overflow-hidden">

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">Ê≠£Âú®Âä†ËΩΩËµÑÊ∫ê...</div>
            <div class="loading-progress-bar">
                <div id="loading-progress" class="loading-progress"></div>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header class="h-[70px] bg-white flex items-center px-5 shrink-0">
        <div class="w-10 h-10 rounded-lg bg-cAccent flex items-center justify-center text-white text-[20px] mr-5">
            ‚úÇÔ∏è
        </div>
        <div class="flex flex-col justify-center">
            <span class="text-[18px] text-cPrimary leading-tight">Ê¢ÖËä±Êô∫ËÉΩÊä†Âõæ</span>
            <span class="text-[10px] text-cSecondary uppercase tracking-[1px] font-medium mt-0.5">AI ÊûÅÁÆÄÂéªÂ∫ïÂ∑•ÂÖ∑</span>
        </div>
        <div class="flex-1"></div>
        <div class="hidden sm:flex h-6 w-20 rounded-[12px] bg-[#f9fafb] border border-cLight items-center justify-center space-x-1.5">
            <div id="status-dot" class="w-2 h-2 rounded-full bg-[#fbbf24]"></div> <!-- Default to processing/loading color -->
            <span id="status-text" class="text-[10px] text-cSecondary">Âä†ËΩΩ‰∏≠...</span>
        </div>
    </header>

    <!-- Toolbar -->
    <div class="h-[60px] bg-white mx-5 mt-5 rounded-lg flex items-center px-[15px] shrink-0">
        <div class="w-1 h-[30px] rounded-[2px] bg-cAccent mr-[15px]"></div>
        <span class="font-bold text-cPrimary text-[14px] mr-4">Â∑•‰ΩúÂè∞</span>
        
        <div id="mode-indicator" class="hidden h-6 rounded bg-cBg border border-cLight items-center justify-center ml-[10px] px-2 gap-2">
            <span class="text-[10px] text-cSecondary">Áü©ÂΩ¢</span>
            <label class="toggle-switch">
                <input type="checkbox" id="mode-switch">
                <span class="slider"></span>
            </label>
            <span class="text-[10px] text-cSecondary">Â§öËæπÂΩ¢</span>
        </div>

        <div class="flex-1"></div>

        <button id="btn-clear-selection" class="px-4 py-1 text-[14px] text-cPrimary hover:bg-gray-50 rounded mr-2 hidden font-medium">Ê∏ÖÈô§ÈÄâÂå∫</button>
        <button id="btn-reset" class="px-4 py-1 text-[14px] text-cPrimary hover:bg-gray-50 rounded mr-2 hidden font-medium">ÈáçÁΩÆ</button>
        
        <input type="file" id="file-input" class="hidden" accept="image/png, image/jpeg">
        <button id="btn-action" class="bg-cAccent hover:bg-cAccentHover text-white font-bold h-[30px] px-6 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-[14px] flex items-center justify-center" disabled>
            Âä†ËΩΩ‰∏≠...
        </button>
    </div>

    <!-- Main Content Split -->
    <main class="flex-1 flex flex-row gap-5 p-5 min-h-0 overflow-hidden">
        
        <!-- Left Panel (Original) -->
        <div class="flex-1 bg-white rounded-lg flex flex-col p-[15px] min-w-0 min-h-0">
            <div class="font-bold text-cSecondary mb-[15px] text-[13px] flex items-center">üì∑ ÂéüÂõæ</div>
            <div class="flex-1 bg-cBg border border-cLight relative flex items-center justify-center overflow-hidden group min-h-0">
                <div id="selection-container" class="hidden selection-container flex">
                    <img id="source-img" class="hidden" draggable="false" />
                    
                    <!-- Selection overlay -->
                    <div id="selection-overlay" class="hidden absolute inset-0 selection-overlay"></div>
                    
                    <!-- Selection box -->
                    <div id="selection-box" class="hidden selection-box">
                        <div class="selection-corner corner-tl"></div>
                        <div class="selection-corner corner-tr"></div>
                        <div class="selection-corner corner-bl"></div>
                        <div class="selection-corner corner-br"></div>
                    </div>
                    
                    <!-- Polygon SVG Layer -->
                    <svg id="polygon-svg" class="hidden polygon-svg">
                        <polygon id="polygon-shape" points="" fill="rgba(232, 167, 152, 0.3)" stroke="#e8a798" stroke-width="2" />
                        <line id="polygon-preview-line" x1="0" y1="0" x2="0" y2="0" stroke="#e8a798" stroke-width="2" stroke-dasharray="4" class="hidden" />
                    </svg>
                    <div id="polygon-points-container"></div>
                    
                    <!-- Tooltip -->
                    <div id="selection-tooltip" class="selection-tooltip">
                        <div class="bg-black/60 text-white px-3 py-1 rounded text-xs backdrop-blur-sm">
                            ÁÇπÂáªÂπ∂ÊãñÂä®‰ª•Ê°ÜÈÄâÂå∫Âüü
                        </div>
                    </div>
                </div>

                <!-- Upload Placeholder -->
                <div id="upload-placeholder" class="flex flex-col items-center cursor-pointer hover:opacity-70 transition-opacity gap-[10px]">
                    <div class="w-[60px] h-[60px] rounded-[30px] bg-white border border-cLight flex items-center justify-center text-2xl">
                        ‚¨ÜÔ∏è
                    </div>
                    <span class="font-bold text-cPrimary text-[13px]">ÁÇπÂáª‰∏ä‰º†ÂõæÁâá</span>
                </div>
            </div>
        </div>

        <!-- Right Panel (Result) -->
        <div class="flex-1 bg-white rounded-lg flex flex-col p-[15px] min-w-0 min-h-0">
            <div class="flex justify-between items-center mb-[15px]">
                <span class="font-bold text-cSecondary text-[13px]">‚ú® ÊïàÊûúÈ¢ÑËßà</span>
                <a id="download-link" class="text-cAccent font-bold text-[13px] cursor-pointer hidden hover:opacity-80">‚¨áÔ∏è ‰∏ãËΩΩ‰øùÂ≠ò</a>
            </div>
            <div class="flex-1 bg-cBg border border-cLight relative flex items-center justify-center overflow-hidden min-h-0">
                <!-- Checkerboard background handled by CSS class on image container if needed, but QML puts it on the rect -->
                <div class="absolute inset-0 m-0.5 checkerboard"></div> 
                
                <img id="result-img" class="max-w-full max-h-full object-contain hidden relative z-10 m-0.5" />
                
                <div id="processing-indicator" class="hidden flex flex-col items-center relative z-20">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-cAccent"></div>
                    <span class="text-xs text-cSecondary mt-2">AI Â§ÑÁêÜ‰∏≠...</span>
                </div>
                
                <span id="result-placeholder" class="text-[#ccc] text-[13px] relative z-10">Â§ÑÁêÜÁªìÊûúÂ∞ÜÂú®Ê≠§ÊòæÁ§∫</span>
            </div>
        </div>
    </main>

    <!-- Load the Wasm Module -->
    <script src="rembg_wasm.js"></script>
    <script>
        let rembgModule = null;
        let rembgInstance = null;
        let isProcessing = false;

        // Selection state
        let selection = null; // { x, y, w, h } in pixels relative to displayed image
        let isDrawing = false;
        let startPos = null; // { x, y }
        
        // Polygon state
        let isPolygonMode = false;
        let polygonPoints = []; // Array of {x, y}
        let draggedPointIndex = -1;

        // Get DOM elements
        const btnAction = document.getElementById('btn-action');
        const btnReset = document.getElementById('btn-reset');
        const btnClearSelection = document.getElementById('btn-clear-selection');
        const fileInput = document.getElementById('file-input');
        const uploadPlaceholder = document.getElementById('upload-placeholder');
        const sourceImg = document.getElementById('source-img');
        const resultImg = document.getElementById('result-img');
        const downloadLink = document.getElementById('download-link');
        const resultPlaceholder = document.getElementById('result-placeholder');
        const processingIndicator = document.getElementById('processing-indicator');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const modeIndicator = document.getElementById('mode-indicator');
        const modeSwitch = document.getElementById('mode-switch');
        const selectionContainer = document.getElementById('selection-container');
        const selectionBox = document.getElementById('selection-box');
        const selectionOverlay = document.getElementById('selection-overlay');
        const selectionTooltip = document.getElementById('selection-tooltip');
        const polygonSvg = document.getElementById('polygon-svg');
        const polygonShape = document.getElementById('polygon-shape');
        const polygonPointsContainer = document.getElementById('polygon-points-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingProgress = document.getElementById('loading-progress');

        // Initialize Module with new memory loading approach
        async function initializeWasm() {
            try {
                // Step 1: Load WASM module (10%)
                loadingProgress.style.width = '10%';
                statusText.textContent = "Âä†ËΩΩ WASM Ê®°Âùó...";
                const module = await createRembg();
                rembgModule = module;
                loadingProgress.style.width = '20%';
                console.log("WASM module loaded");

                // Step 2: Create instance and initialize (30%)
                statusText.textContent = "ÂàùÂßãÂåñÂÆû‰æã...";
                rembgInstance = new rembgModule.RembgWasm();
                if (!rembgInstance.initialize()) {
                    throw new Error("Domain check failed");
                }
                loadingProgress.style.width = '30%';
                console.log("Instance initialized, domain check passed");

                // Step 3: Load param file (40%)
                statusText.textContent = "Âä†ËΩΩÊ®°ÂûãÂèÇÊï∞...";
                const paramResponse = await fetch('model.param');
                const paramBuffer = await paramResponse.arrayBuffer();
                const paramData = new Uint8Array(paramBuffer);
                if (!rembgInstance.loadParam(paramData)) {
                    throw new Error("Failed to load param file");
                }
                loadingProgress.style.width = '40%';
                console.log("Param file loaded");

                // Step 4: Load and merge bin file chunks (40% - 90%)
                statusText.textContent = "Âä†ËΩΩÊ®°ÂûãÊï∞ÊçÆ...";
                const suffixes = ['aa', 'ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj'];
                const chunks = [];
                const progressPerChunk = 50 / suffixes.length; // 50% progress for all chunks
                
                for (let i = 0; i < suffixes.length; i++) {
                    const suffix = suffixes[i];
                    const url = `models.data.part${suffix}`;
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const chunk = new Uint8Array(arrayBuffer);
                    chunks.push(chunk);
                    loadingProgress.style.width = `${40 + (i + 1) * progressPerChunk}%`;
                    console.log(`Loaded chunk ${i + 1}/${suffixes.length}: ${chunk.length} bytes`);
                }

                if (!rembgInstance.loadBinChunks(chunks)) {
                    throw new Error("Failed to load bin chunks");
                }
                loadingProgress.style.width = '90%';
                console.log("Bin chunks loaded and merged");

                // Step 5: Initialize model (95%)
                statusText.textContent = "ÂàùÂßãÂåñÊ®°Âûã...";
                if (!rembgInstance.initModel()) {
                    throw new Error("Failed to initialize model");
                }
                loadingProgress.style.width = '95%';
                console.log("Model initialized successfully");

                // Success
                statusDot.className = "w-2 h-2 rounded-full bg-[#4ade80]";
                statusText.textContent = "Â∞±Áª™";
                btnAction.textContent = "‰∏ä‰º†ÂõæÁâá";
                btnAction.disabled = false;
                loadingProgress.style.width = '100%';

                // Hide loading overlay
                setTimeout(() => {
                    loadingOverlay.classList.add('loading-hidden');
                }, 500);

            } catch (error) {
                console.error("Failed to initialize:", error);
                statusText.textContent = "Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥•";
                statusDot.className = "w-2 h-2 rounded-full bg-red-500";

                setTimeout(() => {
                    loadingOverlay.classList.add('loading-hidden');
                }, 500);
            }
        }

        // Start initialization
        initializeWasm();

        // UI Interactions
        modeSwitch.addEventListener('change', (e) => {
            isPolygonMode = e.target.checked;
            clearSelection();
            
            if (isPolygonMode) {
                selectionBox.classList.add('hidden');
                polygonSvg.classList.remove('hidden');
            } else {
                selectionBox.classList.remove('hidden'); // Logic in updateSelectionUI will handle visibility
                polygonSvg.classList.add('hidden');
            }
        });

        uploadPlaceholder.addEventListener('click', () => fileInput.click());
        btnAction.addEventListener('click', () => {
            if (sourceImg.classList.contains('hidden')) {
                fileInput.click();
            } else {
                processImage();
            }
        });

        btnReset.addEventListener('click', resetUI);
        btnClearSelection.addEventListener('click', clearSelection);

        // Selection mouse events
        selectionContainer.addEventListener('mousedown', handleMouseDown);
        selectionContainer.addEventListener('mousemove', handleMouseMove);
        selectionContainer.addEventListener('mouseup', handleMouseUp);
        selectionContainer.addEventListener('mouseleave', handleMouseUp);

        // Prevent image drag
        sourceImg.addEventListener('dragstart', (e) => e.preventDefault());
        
        // Update selection container size on window resize
        window.addEventListener('resize', () => {
            if (!sourceImg.classList.contains('hidden')) {
                // Use requestAnimationFrame to ensure DOM has updated
                requestAnimationFrame(() => {
                    updateSelectionContainerSize();
                });
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    sourceImg.src = event.target.result;
                    
                    // Show image and setup selection container after image loads
                    sourceImg.onload = () => {
                        showSelectionContainer();
                    };
                    
                    sourceImg.classList.remove('hidden');
                    uploadPlaceholder.classList.add('hidden');
                    btnAction.textContent = "ÂºÄÂßãÊä†Âõæ";
                    btnReset.classList.remove('hidden');
                    modeIndicator.classList.remove('hidden');
                    modeIndicator.classList.add('flex');
                    
                    // Clear previous selection
                    clearSelection();
                    
                    // Clear previous result
                    resultImg.classList.add('hidden');
                    resultImg.src = "";
                    downloadLink.classList.add('hidden');
                    resultPlaceholder.classList.remove('hidden');
                };
                reader.readAsDataURL(file);
            }
        });

        downloadLink.addEventListener('click', () => {
            if (resultImg.src) {
                const link = document.createElement('a');
                let now = new Date();
                let dateStr = now.getFullYear() + 
                    String(now.getMonth() + 1).padStart(2, '0') + 
                    String(now.getDate()).padStart(2, '0') + "_" +
                    String(now.getHours()).padStart(2, '0') + 
                    String(now.getMinutes()).padStart(2, '0');
                link.download = "meihua_" + dateStr + ".png";
                link.href = resultImg.src;
                link.click();
            }
        });

        function resetUI() {
            clearSelection();
            fileInput.value = '';
            sourceImg.src = '';
            sourceImg.classList.add('hidden');
            selectionContainer.classList.add('hidden');
            uploadPlaceholder.classList.remove('hidden');
            resultImg.src = '';
            resultImg.classList.add('hidden');
            resultPlaceholder.classList.remove('hidden');
            downloadLink.classList.add('hidden');
            btnReset.classList.add('hidden');
            btnClearSelection.classList.add('hidden');
            modeIndicator.classList.add('hidden');
            modeIndicator.classList.remove('flex');
            btnAction.textContent = "‰∏ä‰º†ÂõæÁâá";
        }

        function clearSelection() {
            selection = null;
            isDrawing = false;
            startPos = null;
            polygonPoints = [];
            draggedPointIndex = -1;
            updateSelectionUI();
            updatePolygonUI();
        }

        function updateSelectionContainerSize() {
            // Since selection-container now wraps the image, it automatically sizes to fit
            // Just ensure it's visible
            console.log('Selection container displayed with size');
            
            // Clear selection when image size changes
            clearSelection();
        }

        function showSelectionContainer() {
            selectionContainer.classList.remove('hidden');
            // Use setTimeout to ensure DOM has updated before calculating size
            setTimeout(() => {
                updateSelectionContainerSize();
                console.log('Selection container size:', selectionContainer.style.width, selectionContainer.style.height);
            }, 0);
        }

        function getRelativeCoords(e) {
            const rect = selectionContainer.getBoundingClientRect();
            console.log('Mouse event on selection container:', rect);
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function handleMouseDown(e) {
            if (!sourceImg.src || isProcessing) return;
            // Allow event to propagate if it's a double click on a point (handled by point listener)
            // But this is mousedown. Double click is separate.
            
            e.preventDefault();
            e.stopPropagation();
            
            const coords = getRelativeCoords(e);
            
            if (isPolygonMode) {
                // Check if clicking on an existing point via target or coordinates
                let index = -1;
                
                // First check if we clicked a point element
                if (e.target.classList.contains('polygon-point')) {
                    // Find which point it corresponds to
                    // We can store index in dataset, or just search coordinates
                     const points = document.querySelectorAll('.polygon-point');
                     for(let i=0; i<points.length; i++) {
                         if(points[i] === e.target) {
                             index = i;
                             break;
                         }
                     }
                }
                
                // Fallback to coordinate search if not hit directly (e.g. near miss)
                if (index === -1) {
                    const clickRadius = 10;
                    index = polygonPoints.findIndex(p => 
                        Math.abs(p.x - coords.x) < clickRadius && Math.abs(p.y - coords.y) < clickRadius
                    );
                }
                
                draggedPointIndex = index;

                if (draggedPointIndex !== -1) {
                    // Start dragging existing point
                    isDrawing = true;
                } else {
                    // Add new point
                    polygonPoints.push(coords);
                    draggedPointIndex = polygonPoints.length - 1;
                    isDrawing = true; 
                    updatePolygonUI();
                }
            } else {
                startPos = coords;
                isDrawing = true;
                selection = { x: coords.x, y: coords.y, w: 0, h: 0 };
                updateSelectionUI();
            }
        }

        function handleMouseMove(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const coords = getRelativeCoords(e);
            
            if (isPolygonMode) {
                if (draggedPointIndex !== -1) {
                    polygonPoints[draggedPointIndex] = coords;
                    updatePolygonUI();
                }
            } else {
                if (!startPos) return;
                const x = Math.min(coords.x, startPos.x);
                const y = Math.min(coords.y, startPos.y);
                const w = Math.abs(coords.x - startPos.x);
                const h = Math.abs(coords.y - startPos.y);
                
                selection = { x, y, w, h };
                updateSelectionUI();
            }
        }

        function handleMouseUp() {
            if (isPolygonMode) {
                draggedPointIndex = -1;
                isDrawing = false;
            } else {
                if (isDrawing && selection && (selection.w < 5 || selection.h < 5)) {
                    // If selection is too small, treat as a click and clear selection
                    clearSelection();
                }
                isDrawing = false;
                startPos = null;
            }
        }

        function deletePoint(index) {
            polygonPoints.splice(index, 1);
            updatePolygonUI();
        }

        function updatePolygonUI() {
            if (polygonPoints.length > 0) {
                // Show polygon container
                polygonSvg.classList.remove('hidden');
                
                // Update SVG polygon points
                const pointsStr = polygonPoints.map(p => `${p.x},${p.y}`).join(' ');
                polygonShape.setAttribute('points', pointsStr);
                
                // Update points DOM
                polygonPointsContainer.innerHTML = '';
                polygonPoints.forEach((p, index) => {
                    const pointEl = document.createElement('div');
                    pointEl.className = 'polygon-point';
                    pointEl.style.left = p.x + 'px';
                    pointEl.style.top = p.y + 'px';
                    
                    // Add double click to delete
                    pointEl.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        deletePoint(index);
                    });
                    
                    // Add mousedown for dragging (handled by container but we need to identify index)
                    // Actually container's mousedown handles finding the point by distance, which is simpler
                    // but adding explicit listener might be more robust if points overlap. 
                    // Let's stick to the distance check in handleMouseDown for simplicity as implemented above.
                    
                    polygonPointsContainer.appendChild(pointEl);
                });

                // Show clear button
                btnClearSelection.classList.remove('hidden');
            } else {
                 polygonShape.setAttribute('points', "");
                 polygonPointsContainer.innerHTML = '';
                 // Keep SVG visible if mode is polygon, but maybe hide if empty? 
                 // It needs to be visible to capture clicks if it was overlaying, but selection-container captures clicks.
                 // The svg is pointer-events: none, so it's fine.
                 
                 btnClearSelection.classList.add('hidden');
            }
        }

        function updateSelectionUI() {
            if (isPolygonMode) return; // Don't update rect UI in polygon mode
            
            if (selection && selection.w > 0 && selection.h > 0) {
                // Show selection box
                selectionBox.classList.remove('hidden');
                selectionBox.style.left = selection.x + 'px';
                selectionBox.style.top = selection.y + 'px';
                selectionBox.style.width = selection.w + 'px';
                selectionBox.style.height = selection.h + 'px';
                
                // Show overlay
                selectionOverlay.classList.remove('hidden');
                selectionTooltip.classList.add('hidden');
                
                // Update mode indicator
                // modeText.textContent = "Ê®°Âºè: ÊâãÂä®Ê°ÜÈÄâ"; // Removed as modeText is gone
                btnClearSelection.classList.remove('hidden');
            } else {
                // Hide selection
                selectionBox.classList.add('hidden');
                selectionOverlay.classList.add('hidden');
                selectionTooltip.classList.remove('hidden');
                
                // Update mode indicator
                // modeText.textContent = "Ê®°Âºè: Ëá™Âä®Ê£ÄÊµã"; // Removed
                btnClearSelection.classList.add('hidden');
            }
        }

        async function processImage() {
            if (!rembgInstance || isProcessing) return;
            
            isProcessing = true;
            btnAction.disabled = true;
            btnAction.textContent = "Ê≠£Âú®Â§ÑÁêÜ...";
            statusText.textContent = "Â§ÑÁêÜ‰∏≠...";
            statusDot.className = "w-2 h-2 rounded-full bg-[#fbbf24]";
            
            resultPlaceholder.classList.add('hidden');
            processingIndicator.classList.remove('hidden');
            resultImg.classList.add('hidden');

            try {
                // Fetch image data from img src (base64 or blob url)
                const resp = await fetch(sourceImg.src);
                const blob = await resp.blob();
                const arrayBuffer = await blob.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);

                // Calculate selection in actual image pixels
                let cropX = 0, cropY = 0, cropW = 0, cropH = 0;
                
                let activeSelection = selection;
                
                if (isPolygonMode && polygonPoints.length >= 3) {
                    // Calculate bounding box of polygon
                    const xs = polygonPoints.map(p => p.x);
                    const ys = polygonPoints.map(p => p.y);
                    const minX = Math.min(...xs);
                    const maxX = Math.max(...xs);
                    const minY = Math.min(...ys);
                    const maxY = Math.max(...ys);
                    
                    activeSelection = {
                        x: minX,
                        y: minY,
                        w: maxX - minX,
                        h: maxY - minY
                    };
                }
                
                if (activeSelection && activeSelection.w > 0 && activeSelection.h > 0) {
                    // Get the displayed image dimensions and container dimensions
                    const imgRect = sourceImg.getBoundingClientRect();
                    const containerRect = selectionContainer.getBoundingClientRect();
                    
                    const naturalWidth = sourceImg.naturalWidth;
                    const naturalHeight = sourceImg.naturalHeight;
                    
                    // Calculate scale factors
                    const scaleX = naturalWidth / imgRect.width;
                    const scaleY = naturalHeight / imgRect.height;
                    
                    // Calculate offset of the image within the container
                    const offsetX = imgRect.left - containerRect.left;
                    const offsetY = imgRect.top - containerRect.top;
                    
                    // Map selection to image coordinates
                    cropX = Math.floor((activeSelection.x - offsetX) * scaleX);
                    cropY = Math.floor((activeSelection.y - offsetY) * scaleY);
                    cropW = Math.floor(activeSelection.w * scaleX);
                    cropH = Math.floor(activeSelection.h * scaleY);
                    
                    // Ensure values are within bounds of the actual image
                    cropX = Math.max(0, Math.min(cropX, naturalWidth));
                    cropY = Math.max(0, Math.min(cropY, naturalHeight));
                    cropW = Math.max(0, Math.min(cropW, naturalWidth - cropX));
                    cropH = Math.max(0, Math.min(cropH, naturalHeight - cropY));
                }

                // Allow UI to update before heavy processing
                setTimeout(() => {
                    try {
                        // TODO: Implement selection handling if we add crop support
                        const resultU8 = rembgInstance.process(uint8Array, cropX, cropY, cropW, cropH);
                        
                        if (resultU8) {
                            const blob = new Blob([resultU8], { type: 'image/png' });
                            const url = URL.createObjectURL(blob);
                            resultImg.src = url;
                            resultImg.classList.remove('hidden');
                            downloadLink.classList.remove('hidden');
                        } else {
                            alert("Processing returned empty result.");
                        }
                    } catch (e) {
                        console.error(e);
                        alert("Error during processing: " + e.message);
                    } finally {
                        isProcessing = false;
                        btnAction.disabled = false;
                        btnAction.textContent = "ÂºÄÂßãÊä†Âõæ"; 
                        processingIndicator.classList.add('hidden');
                        statusText.textContent = "Â∞±Áª™";
                        statusDot.className = "w-2 h-2 rounded-full bg-[#4ade80]";
                    }
                }, 100);
                
            } catch (e) {
                console.error(e);
                isProcessing = false;
                btnAction.disabled = false;
                processingIndicator.classList.add('hidden');
                statusText.textContent = "Â∞±Áª™";
                statusDot.className = "w-2 h-2 rounded-full bg-[#4ade80]";
            }
        }
    </script>
</body>
</html>
